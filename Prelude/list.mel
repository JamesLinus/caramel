-- Church Lists
-- Most of this was created before Caramel, so its syntax is not used as it could.
-- TODO: refactor and comment this monster!

cons                 = (x list cons nil -> (cons x (list cons nil)))
nil                  = (cons nil -> (id nil))
head                 = (list -> (list (a b -> a) nil))
tail                 = (list cons nil -> (list (h t g -> (g h (t cons))) (const nil) (h t -> t)))
foldr                = (cons nil list -> (list cons nil))
match                = foldr
foldl                = (cons nil list -> (foldr (h t accum -> (t (cons accum h))) id list nil))
push                 = (x -> (foldr cons (cons x nil)))
length               = (flip comp const)
drop                 = (n -> (n tail))
init                 = (list -> (tail (foldr (h t uh -> (cons uh (t h))) (const nil) list 0)))
take                 = (n -> (n (r l -> (cons (head l) (r (tail l)))) (const nil)))
map                  = (f list cons -> (list (comp cons f)))
map_indexed          = (f l -> (foldr (h t i -> (cons (f i h) (t (succ i)))) (const nil) l 0))
filter               = (cond -> (foldr (h t -> (cond h (cons h t) t)) nil))
reverse              = (l c n -> (foldl (flip c) n l))
scan                 = (c n list -> (cons n (foldr (h t x -> (cons (c h x) (t (c h x)))) (const nil) list n)))
last                 = (comp head reverse)
empty                = (foldr (h t -> false) true)
concat               = (a b cons nil -> (a cons (b cons nil)))
flatten              = (foldr concat nil)
seq                  = (foldr comp id)
do                   = (comp seq reverse)
map_vars             = (f n -> (reverse_args n (n (r c -> (r (l x -> (c (cons x l))))) ([]) f)))
bind                 = (x f -> (flatten (map f x)))
return               = (x -> (cons x nil))
suffixes             = (foldr (h t -> (cons (cons h (head t)) t)) nil)
intercalate          = (a b -> ((cont a) (cont b)))
    cont             = (foldr (x xs cont -> (cons x (cont xs))) (const []))
zip_with             = (f a b -> ((left a) (right f b)))
    left             = (foldr (x xs cont -> (cont x xs)) (const []))
    right            = (f -> (foldr (y ys x cont -> (cons (f x y) (cont ys))) (const (const []))))
zip                  = (zip_with pair)
zipp                 = (zip_with id)
cartesian            = (a b -> (flatten (map (x -> (map (cons x) b)) a)))
combinations         = (foldr cartesian [[]])
shift_left           = (list -> (tail (foldr cons [(head list)] list)))
insert               = (x list -> (concat list [x]))
iterated             = (f list -> (foldr (h t g -> (cons (g h) (t (comp f g)))) (const nil) list id))
iterate              = (n next -> (n (rec state -> (cons state (rec (next state)))) (const nil)))
to_tuple_reversed    = (flip (foldr @))
to_tuple             = (flip (foldl id))
split.join           = (st -> (pair nil (cons (pair.get_first st) (pair.get_second st))))
split.cons           = (h st -> (pair (cons h (pair.get_first st)) (pair.get_second st)))
split                = (cond list -> (pair.get_second (split.join (foldr (h st -> (cond h (split.join st) (split.cons h st))) ([],[]) list))))
apply_to_args        = (foldr (h t c v -> (t (c (h v)))) id)
applied              = (flip apply_to_args)
reversed_with        = (f n -> (n (r c -> (r (l x -> (c (cons x l))))) ([]) f))
reversed             = (reversed_with id)
with_2               = (f n -> (map_vars (la -> (map_vars (lb -> (f la lb)) n)) n))
n_list               = (map_vars id)
to_applied_ctor_with = (ctor f list -> (applied (over_n_args (length list) f (ctor (length list))) list))
to_applied_ctor      = (flip to_applied_ctor_with id)
to_applied_tuple     = (to_applied_ctor tuple)
to_applied_list      = (to_applied_ctor n_list)
to_applied_list_with = (to_applied_ctor_with n_list)
intersperse          = (x -> (comp tail (foldr (h t -> (cons x (cons h t))) nil)))
apply_list           = (f -> (comp (@ f) to_tuple))
get_nth              = (nth list -> (tuple.get 2 0 (nth (tuple.get 2 1) (list pair nil))))
mut_nth              = (i -> (f -> (l -> (tuple.mut i f (to_tuple l) (n_list (length l))))))
set_nth              = (i x -> (mut_nth i (const x)))
replicate            = (n x cons nil -> (n (cons x) nil))
all_true             = (foldr and true)
any_true             = (foldr or false)
any                  = (predicate -> (comp any_true (map predicate)))
all                  = (predicate -> (comp all_true (map predicate)))
concat_map           = (f -> (foldr (h t -> (concat (f h) t)) nil))
concat_map_when      = (cond f -> (concat_map (x -> (cond x (f x) [x]))))
insert_after         = (cond el -> (concat_map_when cond (x -> [x,el])))
insert_before        = (cond el -> (concat_map_when cond (x -> [el,x])))
take_while           = (cond -> (foldr (h t -> (cond h (cons h t) nil)) nil))
count_while          = (cond list f x -> (foldr (h t -> (cond h (f t) x)) x list))
germinate.seed       = (n l t -> (t,t))
germinate.go_above   = (n l t -> (@ (top rest -> (t,(top,rest)))))
germinate.go_below   = (n l t -> (@ (top rest -> (rest (a b -> ((n top a),b))))))
germinate.push_elem  = (n l t elem -> (@ (top rest -> ((n (l elem) top),rest))))
germinate.finish     = (id pair.get_first)
treefy.fold          = (n l t open close elem -> (close elem (germinate.go_above n l t) (open elem (germinate.go_below n l t) (germinate.push_elem n l t elem))))
treefy               = (open close list n l t -> (comp germinate.finish (foldr (treefy.fold n l t open close) (germinate.seed n l t)) list))
interact             = (f a b -> (map (a f) b))
self_interact        = (f a -> (interact f a a))
transpose            = (lists -> (foldr zipp (map (const []) (head lists)) (map (map cons) lists)))
distribute           = (n -> (foldr (h t -> (tuple.mut 0 (cons h) (tuple.shift_right n t))) (tuple.repeat n nil)))
chunks_of            = (n l -> (transpose (distribute n l (n_list n))))
for                  = (flip map)
join_delim           = (open delim close list -> (flatten [open,(flatten (intersperse delim list)),close]))


-- Experimental: using derivers to automatically derive
-- some of the list functions based on its ADTs syntax.

List = (a -> #{Cons {head : a, tail : *} | Nil})

Cons         = (Ctor 0 (List Type))
Nil          = (Ctor 1 (List Type))
list:        = (Fold (List Type))
List:        = (foldr Cons Nil)
List*        = (Case (List Type))
Head?        = (Getter 0 0 (List Type))
Tail?        = (Getter 0 1 (List Type))
Head=        = (Setter 0 0 (List Type))
Tail=        = (Setter 0 1 (List Type))
Head@        = (Mutter 0 0 (List Type))
Tail@        = (Mutter 0 1 (List Type))
Head         = (lens Head? Head=)
Tail         = (lens Tail? Tail=)
List.Zipp    = (Zipp (List Type))
List.Fmap    = (Fmap (List Type))
List.ZipWith = (f a b -> (List.Zipp (List.Fmap f a) b))
List.Zip     = (List.ZipWith pair)
List.Foldr   = (cons nil l -> (list: l cons nil))
List.Match   = (Match (List Type))
List.Case    = (Case (List Type))
List.Filter  = (cond list -> (List: (filter cond (list: list))))
List.Flatten = (list -> (List: (flatten (map list: (list: list)))))
