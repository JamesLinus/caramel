-- Array (i.e., bounded intmap) implementation, 
-- using perfectly balanced binary trees.

--  data Arr  : Nat -> Type -> Type where
--      Bin   : Bin k a -> Bin k a -> Bin (S k) a
--      Tip   : a -> Bin Z a
Arr.bin l r = (bin tip -> (bin (l bin tip) (r bin tip)))
Arr.tip x   = (bin tip -> (tip x))
Arr.Bin l r = (bin tip -> (bin l r))
Arr.Tip x   = (bin tip -> (tip x))

-- Arr z a -> (r -> r -> r) -> (a -> r) -> r
Arr.fold arr    = (arr caseBin caseTip)
    caseBin l r = (Arr.bin (Arr.fold l) (Arr.fold r))
    caseTip x   = (Arr.tip x)

--  data Path : Nat -> Type where
    --  End   : Path Z
    --  Left  : Path k -> Path (S k)
    --  Right : Path k -> Path (S k)
Arr.Left p  = (l r e -> (l p))
Arr.Right p = (l r e -> (r p))
Arr.End     = (l r e -> e)
Arr.left p  = (l r e -> (l (p l r e)))
Arr.right p = (l r e -> (r (p l r e)))
Arr.end     = (l r e -> e)

--  go : Path z -> Arr z a -> a
Arr.get path arr = (path left right end arr)
    left go arr  = (arr (left right -> (go left)) Arr.Tip)
    right go arr = (arr (left right -> (go right)) Arr.Tip)
    end arr      = (arr Arr.Bin id)

--  mut : (a -> b) -> Path z -> Arr z a -> Arr z b
Arr.mut f path arr = (path left right end arr)
    left go arr    = (arr (left right -> (Arr.Bin (go left) right)) Arr.Tip)
    right go arr   = (arr (left right -> (Arr.Bin left (go right))) Arr.Tip)
    end arr        = (arr Arr.Bin (comp Arr.Tip f))

--  set : b -> Path z -> Arr z a -> Arr z b
Arr.set x = (Arr.mut (const x))

-- Path z -> Lens (Tree z a) a
Arr.at path = (lens (Arr.get path) (Arr.set path))

suc path           = (path caseLeft caseRight caseEnd)
    caseLeft path  = (Arr.right path)
    caseRight path = (Arr.left (suc path))
    caseEnd path   = Arr.end

Arr.test = (Y Arr.fold tree)
    path = (Arr.left (Arr.left Arr.end))
    tree = (Arr.Bin (Arr.Bin (Arr.Tip 1) (Arr.Tip 2)) (Arr.Bin (Arr.Tip 3) (Arr.Tip 4)))
